<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Paul Fultz II">

<title>reveal - Boost.Fit</title>
<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/styles/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png"></td>
</tr></table>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../result/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../reverse_compress/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#reveal">reveal</a></span></dt>
        <dd><dl>
            
                <dt><span class="section"><a href="#header">Header</a></span></dt>
            
                <dt><span class="section"><a href="#description">Description</a></span></dt>
            
                <dt><span class="section"><a href="#sample">Sample</a></span></dt>
            
                <dt><span class="section"><a href="#synopsis">Synopsis</a></span></dt>
            
                <dt><span class="section"><a href="#requirements">Requirements</a></span></dt>
            
        </dl></dd>
    

    
        <dt><span class="section"><a href="#reporting-failures">Reporting Failures</a></span></dt>
        <dd><dl>
            
                <dt><span class="section"><a href="#header_1">Header</a></span></dt>
            
                <dt><span class="section"><a href="#synopsis_1">Synopsis</a></span></dt>
            
                <dt><span class="section"><a href="#example">Example</a></span></dt>
            
        </dl></dd>
    

</dl>
</div>



<div class="section">
<h1 id="reveal">reveal</h1>
<h2 id="header">Header</h2>
<pre><code>#include &lt;boost/fit/reveal.hpp&gt;
</code></pre>
<h2 id="description">Description</h2>
<p>The <code>reveal</code> function adaptor helps shows the error messages that get
masked on some compilers. Sometimes an error in a function that causes a
substitution failure, will remove the function from valid overloads. On
compilers without a backtrace for substitution failure, this will mask the
error inside the function. The <code>reveal</code> adaptor will expose these error
messages while still keeping the function SFINAE-friendly.</p>
<h2 id="sample">Sample</h2>
<p>If we take the <code>print</code> example from the quick start guide like this:</p>
<pre><code>namespace adl {

using std::begin;

template&lt;class R&gt;
auto adl_begin(R&amp;&amp; r) BOOST_FIT_RETURNS(begin(r));
}

BOOST_FIT_STATIC_LAMBDA_FUNCTION(for_each_tuple) = [](const auto&amp; sequence, auto f) BOOST_FIT_RETURNS
(
    boost::fit::unpack(boost::fit::by(f))(sequence)
);

auto print = boost::fit::fix(boost::fit::conditional(
    [](auto, const auto&amp; x) -&gt; decltype(std::cout &lt;&lt; x, void())
    {
        std::cout &lt;&lt; x &lt;&lt; std::endl;
    },
    [](auto self, const auto&amp; range) -&gt; decltype(self(*adl::adl_begin(range)), void())
    {
        for(const auto&amp; x:range) self(x);
    },
    [](auto self, const auto&amp; tuple) -&gt; decltype(for_each_tuple(tuple, self), void())
    {
        return for_each_tuple(tuple, self);
    }
));
</code></pre>
<p>Which prints numbers and vectors:</p>
<pre><code>print(5);

std::vector&lt;int&gt; v = { 1, 2, 3, 4 };
print(v);
</code></pre>
<p>However, if we pass a type that can't be printed, we get an error like
this:</p>
<pre><code>print.cpp:49:5: error: no matching function for call to object of type 'boost::fit::fix_adaptor&lt;boost::fit::conditional_adaptor&lt;(lambda at print.cpp:29:9), (lambda at print.cpp:33:9), (lambda at print.cpp:37:9)&gt; &gt;'
    print(foo{});
    ^~~~~
fix.hpp:158:5: note: candidate template ignored: substitution failure [with Ts = &lt;foo&gt;]: no matching function for call to object of type 'const boost::fit::conditional_adaptor&lt;(lambda at
      print.cpp:29:9), (lambda at print.cpp:33:9), (lambda at print.cpp:37:9)&gt;'
    operator()(Ts&amp;&amp;... xs) const BOOST_FIT_SFINAE_RETURNS
</code></pre>
<p>Which is short and gives very little information why it can't be called.
It doesn't even show the overloads that were try. However, using the
<code>reveal</code> adaptor we can get more info about the error like this:</p>
<pre><code>print.cpp:49:5: error: no matching function for call to object of type 'boost::fit::reveal_adaptor&lt;boost::fit::fix_adaptor&lt;boost::fit::conditional_adaptor&lt;(lambda at print.cpp:29:9), (lambda at print.cpp:33:9),
      (lambda at print.cpp:37:9)&gt; &gt;, boost::fit::fix_adaptor&lt;boost::fit::conditional_adaptor&lt;(lambda at print.cpp:29:9), (lambda at print.cpp:33:9), (lambda at print.cpp:37:9)&gt; &gt; &gt;'
    boost::fit::reveal(print)(foo{});
    ^~~~~~~~~~~~~~~~~~
reveal.hpp:149:20: note: candidate template ignored: substitution failure [with Ts = &lt;foo&gt;, $1 = void]: no matching function for call to object of type '(lambda at print.cpp:29:9)'
    constexpr auto operator()(Ts&amp;&amp;... xs) const
                   ^
reveal.hpp:149:20: note: candidate template ignored: substitution failure [with Ts = &lt;foo&gt;, $1 = void]: no matching function for call to object of type '(lambda at print.cpp:33:9)'
    constexpr auto operator()(Ts&amp;&amp;... xs) const
                   ^
reveal.hpp:149:20: note: candidate template ignored: substitution failure [with Ts = &lt;foo&gt;, $1 = void]: no matching function for call to object of type '(lambda at print.cpp:37:9)'
    constexpr auto operator()(Ts&amp;&amp;... xs) const
                   ^
fix.hpp:158:5: note: candidate template ignored: substitution failure [with Ts = &lt;foo&gt;]: no matching function for call to object of type 'const boost::fit::conditional_adaptor&lt;(lambda at
      print.cpp:29:9), (lambda at print.cpp:33:9), (lambda at print.cpp:37:9)&gt;'
    operator()(Ts&amp;&amp;... xs) const BOOST_FIT_SFINAE_RETURNS
</code></pre>
<p>So now the error has a note for each of the lambda overloads it tried. Of
course this can be improved even further by providing custom reporting of
failures.</p>
<h2 id="synopsis">Synopsis</h2>
<pre><code>template&lt;class F&gt;
reveal_adaptor&lt;F&gt; reveal(F f);
</code></pre>
<h2 id="requirements">Requirements</h2>
<p>F must be:</p>
<ul>
<li><a href="../concepts/index.html#constcallable">ConstCallable</a></li>
<li>MoveConstructible</li>
</ul>
<h1 id="reporting-failures">Reporting Failures</h1>
<h2 id="header_1">Header</h2>
<pre><code>#include &lt;boost/fit/reveal.hpp&gt;
</code></pre>
<p>By default, <code>reveal</code> reports the substitution failure by trying to call
the function. However, more detail expressions can be be reported from a
template alias by using <code>as_failure</code>. This is done by defining a nested
<code>failure</code> struct in the function object and then inheriting from
<code>as_failure</code>. Also multiple failures can be reported by using
<code>with_failures</code>.</p>
<h2 id="synopsis_1">Synopsis</h2>
<pre><code>// Report failure by instantiating the Template
template&lt;template&lt;class...&gt; class Template&gt;
struct as_failure;

// Report multiple falures
template&lt;class... Failures&gt;
struct with_failures;

// Report the failure for each function
template&lt;class... Fs&gt;
struct failure_for;

// Get the failure of a function
template&lt;class F&gt;
struct get_failure;
</code></pre>
<h2 id="example">Example</h2>
<pre><code>struct sum_f
{
    template&lt;class T, class U&gt;
    using sum_failure = decltype(std::declval&lt;T&gt;()+std::declval&lt;U&gt;());

    struct failure
    : as_failure&lt;sum_failure&gt;
    {};

    template&lt;class T, class U&gt;
    auto operator()(T x, U y) const BOOST_FIT_RETURNS(x+y);
};
</code></pre>
</div>

<script src="../js/highlight.pack.js"></script>
<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>
<script src="../js/configure.js"></script>

<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Paul Fultz II
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at 
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>

</div>
</body>
</html>